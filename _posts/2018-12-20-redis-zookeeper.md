---
title: 分布式锁的原理和实现方式
category: blog
date: '2018-12-20 18:03:23'
tag:
- 分布式锁
- Redis
- Zookeeper
layout: post
---

## 为什么要使用分布式锁

单机应用，也就是所有的请求都会分配到当前服务器的JVM内部，然后映射为操作系统的线程进行处理！而这个共享变量只是在这个JVM内部的一块内存空间！

后来业务发展，需要做集群，一个应用需要部署到几台机器上然后做负载均衡，大致如下图：

![](https://img-blog.csdn.net/20180111171903380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

上图可以看到，`变量A`存在`JVM1`、`JVM2`、`JVM3`三个`JVM内存`中（这个`变量A`主要体现是在一个类中的一个成员变量，是一个有状态的对象，例如：`UserController控制器`中的一个整形类型的成员变量），如果不加任何控制的话，`变量A`同时都会在`JVM`分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的！即使不是同时发过来，三个请求分别操作三个不同`JVM内存区域`的数据，`变量A`之间不存在共享，也不具有可见性，处理的结果也是不对的！

为了保证一个方法或属性在高并发情况下的`同一时间`只能被`同一个线程`执行，在传统单体应用单机部署的情况下，可以使用`Java`并发处理相关的`API`(如`ReentrantLock`或`Synchronized`)进行互斥控制。在单机环境中，`Java`中提供了很多并发处理相关的`API`。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的`Java API`并不能提供分布式锁的能力。为了解决这个问题就需要一种跨`JVM`的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！


## 比较典型的应用场景

#### 秒杀系统
其实秒杀类场景最主要的是执行秒杀操作要单线程的，提到单线程，肯定会想到synchronized关键字，但是他有两个致命缺点：
* 无法做到细粒度控制
* 只适合单点不适用集群
所以大多数项目只能采用分布式锁的实现方式

#### 支付系统
比较敏感的数据比如金额修改，同一时间只能有一个人操作，想象下2个人同时修改金额，一个加金额一个减金额，为了防止同时操作造成数据不一致，需要锁，如果是数据库需要的就是行锁或表锁，
如果是在集群里，多个客户端同时修改一个共享的数据就需要分布式锁。

## 二、分布式锁应该具备哪些条件
在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：

1. 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 
1. 高可用的获取锁与释放锁； 
1. 高性能的获取锁与释放锁； 
1. 具备可重入特性； 
1. 具备锁失效机制，防止死锁； 
1. 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。

## 三、分布式锁的三种实现方式
目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的`CAP理论`告诉我们“任何一个分布式系统都无法同时满足`一致性（Consistency）`、`可用性（Availability）`和`分区容错性（Partition tolerance）`，最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。

在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如`分布式事务`、`分布式锁`等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。

1. 基于数据库实现分布式锁； 
1. 基于缓存（Redis等）实现分布式锁； 
1. 基于Zookeeper实现分布式锁；

> 尽管有这三种方案，但是不同的业务也要根据自己的情况进行选型，他们之间没有最好只有更适合！

## 四、基于数据库的实现方式

基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

创建一个表：

```sql
DROP TABLE IF EXISTS `method_lock`;
CREATE TABLE `method_lock` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `method_name` varchar(64) NOT NULL COMMENT '锁定的方法名',
  `desc` varchar(255) NOT NULL COMMENT '备注信息',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';

```

> method_name 设置成`UNIQUE KEY`

想要执行某个方法，就使用这个方法名向表中插入数据：

```sql
INSERT INTO method_lock (method_name, desc) VALUES ('methodName', '测试的methodName');
```

因为我们对`method_name`做了`唯一性约束`，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。

成功插入则获取锁，执行完成后删除对应的行数据释放锁：

```sql
delete from method_lock where method_name ='methodName';
```

> 注意：这只是使用基于数据库的一种方法，使用数据库实现分布式锁还有很多其他的玩法！

#### 优化

使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化：

1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；

2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；

3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；

4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。

5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。


## 五、基于Redis的实现方式

#### 1、选用Redis实现分布式锁原因：
1. Redis有很高的性能； 
1. Redis命令对此支持较好，实现起来比较方便

#### 2、使用命令介绍：
（1）SETNX
```shell
SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。
```

（2）expire
```shell
expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。
```

（3）delete
```shell
delete key：删除key
```

在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。

#### 3、实现思想：

（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。

（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。

（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。

#### 4、 分布式锁的简单实现代码：


#### 5、基于ZooKeeper的实现方式

`ZooKeeper`是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于`ZooKeeper`实现分布式锁的步骤如下：

创建一个目录`mylock`； 
线程`A`想获取锁就在`mylock`目录下创建临时顺序节点； 
获取`mylock`目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； 
线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； 
线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

这里推荐一个`Apache`的开源库`Curator`，它是一个`ZooKeeper客户端`，`Curator`提供的`InterProcessMutex`是分布式锁的实现，`acquire方法`用于获取锁，`release方法`用于释放锁。

优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。