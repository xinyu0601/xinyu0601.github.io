---
title: 深入理解缓存
category: blog
layout: post
tag:
- redis
- 缓存
date: '2019-01-08 12:25:54'
---

## 什么是缓存
缓存，就是数据交换的`缓冲区`，针对服务对象的不同（本质就是不同的硬件）都可以构建缓存。

**目的是，把读写速度慢的介质的数据保存在读写速度快的介质中，从而提高读写速度，减少时间消耗。**

## 为什么要用缓存？
正如在 「什么是缓存？」 问题中所看到的，**使用缓存的目的，就是提升读写性能。** 而实际业务场景下，更多的是为了提升读性能，带来更好的性能，更高的并发量。

日常业务中，我们使用比较多的数据库是 MySQL ，缓存是 Redis 。

如此一比较，Redis 比 MySQL 的读写性能好很多。那么，**我们将 MySQL 的热点数据，缓存到 Redis 中**，提升读取性能，也减小 MySQL 的读取压力。

## 缓存算法

缓存算法，比较常见的是三种：

* LRU（least recently used ，最近最少使用)
* LFU（Least Frequently used ，最不经常使用)
* FIFO（first in first out ，先进先出)

## 有哪些常见问题

常见的问题，可列举如下：

1. 缓存何时写入？并且写时如何避免并发重复写入？
1. 缓存如何失效？
1. 缓存和 DB 的一致性如何保证？
1. 如何避免缓存穿透的问题？
1. 如何避免缓存击穿的问题？
1. 如果避免缓存雪崩的问题？

#### 缓存”穿透”问题

缓存穿透，是指查询一个一定不存在的数据，由于缓存是不命中时被动写( 被动写，指的是从 DB 查询到数据，则更新到缓存中 )的，并且处于容错考虑，如果从 DB 查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，失去了缓存的意义。

在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。如下图：

![](http://www.iocoder.cn/images/Cache/2019-11-21/01.png)

> MySQL 的性能是远不如 Redis 的，如果大量的请求直接打到 MySQL ，则会直接打挂 MySQL 。

**如何解决**
1. 方案一，缓存空对象
1. 方案二，BloomFilter 布隆过滤器

#### 缓存”雪崩”的问题

缓存雪崩，是指缓存由于某些原因无法提供服务( 例如，缓存挂掉了 )，所有请求全部达到 DB 中，导致 DB 负荷大增，最终挂掉的情况。

**如何解决？**

预防和解决缓存雪崩的问题，可以从以下多个方面进行共同着手。

***缓存高可用***
通过搭建缓存的高可用，避免缓存挂掉导致无法提供服务的情况，从而降低出现缓存雪崩的情况。

***本地缓存***

如果使用本地缓存时，即使分布式缓存挂了，也可以将 DB 查询到的结果缓存到本地，避免后续请求全部到达 DB 中。

***请求 DB 限流***

通过限制 DB 的每秒请求数，避免把 DB 也打挂了。这样至少能有两个好处：

可能有一部分用户，还可以使用，系统还没死透。
未来缓存服务恢复后，系统立即就已经恢复，无需在处理 DB 也挂掉的情况。

***服务降级***

如果请求被限流，或者请求 DB 超时，我们可以服务降级，提供一些默认的值，或者友情提示，甚至空白的值也行。

如果我们使用 Java ，则可以使用`Hystrix`、`Sentinel` 实现限流的功能。

***提前演练***

在项目上线前，演练缓存宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。

#### 缓存”击穿”的问题

缓存击穿，是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB 加载数据并回设到缓存，但是这个时候大并发的请求可能会瞬间 DB 压垮。

**如何解决**

有两种方案可以解决：

方案一，使用互斥锁：请求发现缓存不存在后，去查询 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。流程如下：
* 1、获取分布式锁，直到成功或超时。如果超时，则抛出异常，返回。如果成功，继续向下执行。
* 2、再去缓存中。如果存在值，则直接返回；如果不存在，则继续往下执行。因为，获得到锁，可能已经被“那个”线程去查询过 DB ，并更新到缓存中了。
* 3、查询 DB ，并更新到缓存中，返回值。

方案二，手动过期：缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里，如果发现要过期，通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，保证有且只有一个线程去查询 DB。

#### ”雪崩”和”击穿”的区别

* 缓存被“击穿”的问题，和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多 KEY 。
* 缓存被“击穿”的问题，和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。